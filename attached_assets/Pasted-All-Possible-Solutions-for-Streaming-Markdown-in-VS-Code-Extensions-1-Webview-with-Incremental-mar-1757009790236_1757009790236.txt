All Possible Solutions for Streaming Markdown in VS Code Extensions
1
Webview with Incremental marked/markdown-it + Debouncing
Stream text into a webview; use a Markdown parser (e.g.,
marked
) to render as it arrives, with logic to delay unsafe renders (e.g., mid-code block).
- Full control
- Rich formatting
- Can add syntax highlighting, math, etc.
- Real-time updates
- Must manage partial parsing
- Risk of broken HTML if not careful
- Need to bundle JS/CSS
Continue.dev
,
CodeSandbox AI
,
Phind
,
Cursor.sh
2
Write to a .md file + VS Code‚Äôs Built-in Preview
Append streamed Markdown to a temporary
.md
file and open it with
markdown.showPreview
.
- Perfect formatting (uses VS Code‚Äôs native engine)
- Zero parsing bugs
- Full syntax highlighting, math, links, images
- Slight I/O overhead
- Less UI control
- Harder to customize layout
GitHub Copilot Chat (sometimes)
,
Jupyter Notebooks in VS Code
3
Virtual Document + Custom Language Server
Create a virtual Markdown document using
vscode.workspace.registerTextDocumentContentProvider
, stream content there, and let VS Code render it.
- Clean integration
- Supports live preview
- No file pollution
- Complex setup
- Overkill for simple use cases
GitHub Copilot Chat
,
LangChain
, some AI notebooks
4
Inline Decorations in Editor (for small snippets)
Use
TextEditor.setDecorations()
to show rendered-like Markdown inline (e.g., for AI comments or hints).
- Lightweight
- No webview needed
- Very limited formatting
- Not suitable for full Markdown
GitHub Copilot (suggestions)
,
Tabnine inline
5
Snippet Insertion with SnippetString
Stream into a buffer, then insert as a formatted snippet after completion.
- Clean insertion
- Preserves indentation
- Not real-time
- No intermediate preview
GitHub Copilot (completions)
6
Custom Incremental Parser (DIY streaming-markdown)
Build a parser that buffers text and only renders when safe (e.g., after
\n
,
```
,
$$
). Auto-close unclosed blocks.
- High control
- Optimized for streaming
- Requires maintenance
- Edge cases (lists, quotes) are hard
Custom AI tools
,
in-house LLM UIs
7
ANSI-to-HTML + Preformatted Blocks
If output is plain text with minimal formatting, wrap in
<pre>
and handle basic escapes.
- Fast
- Simple
- No real Markdown support
- Poor for rich content
CLI tools
,
basic logs
8
Use marked in Streaming Mode with tokenizer Hooks
Extend
marked
with custom tokenizer that detects incomplete tokens (e.g., unclosed code block) and delays rendering.
- Precise control
- Can pause on ambiguity
- Complex
- Fragile if not tested well
Advanced notebook UIs
üß† How Real LLM Extensions Handle It
üîπ GitHub Copilot (Chat & Inline)
Inline Completions: Uses decorations and snippets ‚Äî not full Markdown.
Copilot Chat:
Uses a webview with custom rendering.
Streams Markdown incrementally.
Delays syntax highlighting until code blocks are closed.
Auto-detects language tags (e.g., ```js).
Uses debounced updates and heuristic buffering.
üîπ Continue.dev / CodeSandbox AI
Full webview-based chat UI.
Uses markdown-it with plugins:
markdown-it-highlightjs for syntax highlighting
markdown-it-math for LaTeX
Implements auto-closing fences and stream-aware parsing.
Updates preview every ~100ms or on newline.
üîπ Cursor.sh / Phind / Warp (AI Editors)
Render streaming Markdown in a rich editor-like webview.
Use contenteditable divs with custom parsing.
Apply formatting only after delimiters (e.g., ```) are complete.
üîπ Jupyter Notebooks in VS Code
Uses virtual documents and incremental cell output.
Renders streamed Markdown/Math via trusted webview.
Finalizes output on completion.
‚úÖ Recommended Solution (Best Practice)
üèÜ Best Overall: #1 + #6 ‚Üí Webview with Smart Incremental Parsing 

‚úÖ Recommended Architecture
ts


1
2
3
4
5
6
7
8
9
10
11
12
‚åÑ
‚åÑ
‚åÑ
// 1. Stream from SSE
for await (const chunk of fetchSSE(...)) {
  renderer.append(chunk);

  // Debounce update
  debounce(() => {
    webview.postMessage({
      type: 'update',
      html: renderer.toHtml() // safely rendered
    });
  }, 100);
}
ts


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
‚åÑ
‚åÑ
‚åÑ
‚åÑ
// 2. Use a `StreamingMarkdownRenderer` (DIY)
class StreamingMarkdownRenderer {
  private content = '';

  append(chunk: string) {
    this.content += chunk;
  }

  toHtml() {
    // Auto-close code blocks
    const fenced = this.ensureClosedFences(this.content);
    // Use marked or markdown-it
    return marked.parse(fenced);
  }

  private ensureClosedFences(text: string) {
    const count = (text.match(/```/g) || []).length;
    if (count % 2 === 1) return text + '\n```';
    return text;
  }
}
html


1
2
3
4
5
6
7
8
9
10
11
‚åÑ
‚åÑ
<!-- 3. Webview with syntax highlighting -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>

<script>
  window.addEventListener('message', (event) => {
    document.getElementById('preview').innerHTML = event.data.html;
    setTimeout(() => Prism.highlightAll(), 0);
  });
</script>
üèÖ Final Recommendation Summary
Full Markdown chat (AI assistant)
‚úÖ
Webview + marked + auto-close + debounce
Want perfect formatting with zero bugs
‚úÖ
Write to .md file + markdown.showPreview
Need deep integration with editor
‚úÖ
Virtual document + content provider
Simple inline hints or tooltips
‚úÖ
Decorations or hover providers
Building a notebook-style UI
‚úÖ
Virtual documents + webview output
üöÄ Pro Tips
Debounce updates (50‚Äì100ms) to avoid re-rendering on every character.
Auto-close code blocks ‚Äî users expect them to render.
Sanitize HTML if using untrusted sources (use DOMPurify in webview).
Support math with marked.use({ hooks: ... }) + KaTeX.
Let users copy rendered text via webview message commands.
Show a "streaming‚Ä¶" indicator and hide it on completion.